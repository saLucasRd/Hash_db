import React, { useMemo, useRef, useState } from "react";

// ============================\n// ÍNDICE HASH ESTÁTICO – React\n// ============================\n// Requisitos atendidos:\n// - Interface gráfica com ilustração das estruturas (páginas, buckets e overflows).\n// - Construção do índice a partir de um arquivo .txt (uma palavra por linha) OU do repositório do GitHub.\n// - Busca por chave usando o índice (com custo estimado de leituras de página).\n// - Table Scan até encontrar a chave (com custo e tempo).\n// - Parâmetros: tamanho da página (tuplas por página) OU número de páginas (mutuamente exclusivos),\n//   tamanho de bucket (FR), NB calculado (NB > NR/FR).\n// - Colisões e overflow tratados (encadeamento externo em listas de overflow).\n// - Estatísticas: taxa de colisões, taxa de overflow, custos (leituras de páginas), diferença de tempo.\n\n// \n// COMO USAR NO VITE:\n// 1) Crie o projeto (já feito): npm create vite@latest indice-hash -- --template react\n// 2) Instale deps: npm install\n// 3) Substitua o conteúdo de src/App.jsx por este arquivo.\n// 4) npm run dev.\n\n// Utilitário de tempo simples\nconst now = () => (performance?.now ? performance.now() : Date.now());\n\n// Função Hash (polinomial base 31) – retorna índice no intervalo [0, mod)\nfunction hashString(key, mod) {\n  let h = 0;\n  for (let i = 0; i < key.length; i++) {\n    h = (h * 31 + key.charCodeAt(i)) >>> 0;\n  }\n  return h % mod;\n}\n\nexport default function App() {\n  // DADOS E PARÂMETROS\n  const [linhas, setLinhas] = useState([]); // todas as tuplas (palavras)\n  const [tuplasPorPagina, setTuplasPorPagina] = useState(100); // tamanho da página (em tuplas)\n  const [usarNumPaginas, setUsarNumPaginas] = useState(false); // alterna o modo de entrada\n  const [numPaginasInput, setNumPaginasInput] = useState(0); // número de páginas escolhido pelo usuário (opcional)\n  const [fr, setFr] = useState(8); // FR = tamanho do bucket (capacidade)\n\n  // ESTRUTURAS DERIVADAS\n  const [paginas, setPaginas] = useState([]); // páginas físicas (array de arrays)\n  const [buckets, setBuckets] = useState([]); // buckets principais: cada bucket é um array de entradas {chave, pagina}\n  const [overflow, setOverflow] = useState({}); // overflow[b]: lista extra de entradas do bucket b\n\n  // ESTADO DE CONTROLE/INFO\n  const [nb, setNb] = useState(0); // número de buckets calculado (NB > NR/FR)\n  const [estat, setEstat] = useState(null); // estatísticas agregadas\n  const [construido, setConstruido] = useState(false);\n  const [chaveBusca, setChaveBusca] = useState("");\n  const [resultadoBusca, setResultadoBusca] = useState(null); // resultado de uma busca via índice\n  const [resultadoScan, setResultadoScan] = useState(null); // resultado de um table scan\n  const fileRef = useRef(null);\n\n  // Exemplos (para testar rápido sem arquivo)\n  const exemplo = useMemo(() =>\n    ["macadamia","banana","laranja","uva","kiwi","melancia","pera","pessego","manga","morango","mirtilo","abacaxi","abacate","damasco","amora","coco","tamara","figo","goiaba","limao"],\n  []);\n\n  // Carregar arquivo .txt local (uma palavra por linha)\n  function onFile(e) {\n    const f = e.target.files?.[0];\n    if (!f) return;\n    const reader = new FileReader();\n    reader.onload = (ev) => {\n      const txt = String(ev.target.result || "");\n      const arr = txt.split(/\r?\n/).map(s => s.trim()).filter(Boolean);\n      setLinhas(arr);\n      resetEstruturas();\n    };\n    reader.readAsText(f);\n  }\n\n  // Buscar direto do GitHub (arquivo words_alpha.txt do repo dwyl/english-words)\n  async function carregarDoGitHub() {\n    try {\n      // URL do raw para evitar CORS do HTML do GitHub\n      const url = "https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt";\n      const resp = await fetch(url);\n      const txt = await resp.text();\n      const arr = txt.split(/\r?\n/).map(s => s.trim()).filter(Boolean);\n      setLinhas(arr);\n      resetEstruturas();\n    } catch (e) {\n      alert("Falha ao carregar do GitHub: " + e.message);\n    }\n  }\n\n  function usarExemplo() {\n    setLinhas(exemplo);\n    resetEstruturas();\n  }\n\n  function resetEstruturas() {\n    setPaginas([]);\n    setBuckets([]);\n    setOverflow({});\n    setEstat(null);\n    setNb(0);\n    setConstruido(false);\n    setResultadoBusca(null);\n    setResultadoScan(null);\n    if (fileRef.current) fileRef.current.value = "";\n  }\n\n  // Construção do índice (cumpre passos 7a..7f)\n  function construirIndice() {\n    if (!linhas.length) {\n      alert("Carregue um arquivo de dados ou use o exemplo.");\n      return;\n    }\n\n    const NR = linhas.length; // cardinalidade (nº de tuplas)\n\n    // Determinar tuplasPorPagina e numPaginas (mutuamente exclusivos)\n    let tpp = Math.max(1, Math.floor(Number(tuplasPorPagina) || 1));\n    let numPaginas = Math.ceil(NR / tpp);\n    if (usarNumPaginas && Number(numPaginasInput) > 0) {\n      numPaginas = Math.max(1, Math.floor(Number(numPaginasInput)));\n      tpp = Math.ceil(NR / numPaginas);\n    }\n\n    // Criar páginas físicas (7b, 7c)\n    const novasPaginas = Array.from({ length: numPaginas }, () => []);\n    for (let i = 0; i < NR; i++) {\n      const p = Math.min(Math.floor(i / tpp), numPaginas - 1);\n      novasPaginas[p].push(linhas[i]);\n    }\n\n    // Definir NB (4d): NB > NR/FR\n    const FR = Math.max(1, Math.floor(Number(fr) || 1));\n    const NB = Math.ceil(NR / FR) + 1;\n\n    // Inicializar buckets e estruturas de overflow\n    const novosBuckets = Array.from({ length: NB }, () => []);\n    const novosOverflows = {}; // chave: índice do bucket -> array extra\n\n    // Preencher índice percorrendo página por página (7e, 7f)\n    let colisoes = 0;\n    let qtdOverflow = 0;\n    for (let p = 0; p < novasPaginas.length; p++) {\n      const page = novasPaginas[p];\n      for (let t = 0; t < page.length; t++) {\n        const chave = page[t];\n        const b = hashString(chave, NB);\n        if (novosBuckets[b].length > 0) colisoes++; // colisão ao inserir em bucket não vazio\n        if (novosBuckets[b].length < FR) {\n          novosBuckets[b].push({ chave, pagina: p });\n        } else {\n          if (!novosOverflows[b]) novosOverflows[b] = [];\n          novosOverflows[b].push({ chave, pagina: p });\n          qtdOverflow++;\n        }\n      }\n    }\n\n    const taxaColisoes = (colisoes / NR) * 100;\n    const taxaOverflow = (qtdOverflow / NR) * 100;\n\n    setPaginas(novasPaginas);\n    setBuckets(novosBuckets);\n    setOverflow(novosOverflows);\n    setNb(NB);\n    setEstat({ NR, FR, NB, tpp, numPaginas, colisoes, qtdOverflow, taxaColisoes, taxaOverflow });\n    setConstruido(true);\n  }\n\n  // Busca usando o índice (cumpre 7g..7i)\n  function buscarComIndice() {\n    if (!construido) { alert("Construa o índice primeiro."); return; }\n    const alvo = (chaveBusca || "").trim();\n    if (!alvo) return;\n\n    const t0 = now();\n    const b = hashString(alvo, nb);\n    let acessosDePagina = 0; // custo em páginas lidas no disco\n\n    // Procurar no bucket principal\n    const lista = buckets[b] || [];\n    let entrada = lista.find((x) => x.chave === alvo);\n    if (!entrada && overflow[b]) {\n      // Procurar nas listas de overflow daquele bucket\n      entrada = (overflow[b] || []).find((x) => x.chave === alvo);\n    }\n\n    let paginaEncontrada = null;\n    if (entrada) {\n      // Custos: 1 acesso de página para ler a página onde está a tupla\n      paginaEncontrada = entrada.pagina;\n      acessosDePagina = 1;\n    }\n\n    const t1 = now();\n    setResultadoBusca({\n      chave: alvo,\n      encontrada: !!entrada,\n      pagina: paginaEncontrada,\n      custoPaginas: acessosDePagina,\n      tempoMs: (t1 - t0).toFixed(3),\n      bucket: b,\n    });\n  }\n\n  // Table Scan (cumpre 7j)\n  function tableScan() {\n    if (!construido) { alert("Construa o índice primeiro."); return; }\n    const alvo = (chaveBusca || "").trim();\n    if (!alvo) return;\n\n    const t0 = now();\n    let acessos = 0;\n    let pagina = null;\n    for (let p = 0; p < paginas.length; p++) {\n      acessos++; // custo: leitura da página p\n      if (paginas[p].includes(alvo)) {\n        pagina = p;\n        break;\n      }\n    }\n    const t1 = now();\n    setResultadoScan({ chave: alvo, encontrada: pagina !== null, pagina, custoPaginas: acessos, tempoMs: (t1 - t0).toFixed(3) });\n  }\n\n  // Diferença de tempo (6e, 7k) – calculada dinamicamente quando ambos resultados existem\n  const diffTempo = useMemo(() => {\n    if (!resultadoBusca || !resultadoScan) return null;\n    return (Number(resultadoScan.tempoMs) - Number(resultadoBusca.tempoMs)).toFixed(3);\n  }, [resultadoBusca, resultadoScan]);\n\n  // Renderização auxiliar – páginas e buckets\n  function RenderPaginas() {\n    if (!paginas.length) return null;\n    const primeira = 0;\n    const ultima = paginas.length - 1;\n    return (\n      <div className="grid" style={{display:'grid',gap:12,gridTemplateColumns:'repeat(auto-fit,minmax(260px,1fr))'}}>\n        <div className="card">\n          <h4>Página #{primeira}</h4>\n          <small>Registros</small>\n          <pre className="box">{paginas[primeira].slice(0,50).join("\n") || "(vazia)"}</pre>\n        </div>\n        <div className="card">\n          <h4>Página #{ultima}</h4>\n          <small>Registros</small>\n          <pre className="box">{paginas[ultima].slice(0,50).join("\n") || "(vazia)"}</pre>\n        </div>\n      </div>\n    );\n  }\n\n  function RenderBuckets() {\n    if (!buckets.length) return null;\n    return (\n      <div>\n        <h3>Mapa de Buckets (NB = {nb}, FR = {estat?.FR})</h3>\n        <div className="grid" style={{display:'grid',gap:10,gridTemplateColumns:'repeat(auto-fit,minmax(220px,1fr))'}}>\n          {buckets.map((arr, i) => {\n            const of = overflow[i] || [];\n            return (\n              <div key={i} className="bucket">\n                <div className="bucket-head">Bucket {i}</div>\n                <div className="bucket-body">\n                  <div className="slot-list">\n                    {arr.length === 0 ? <div className="slot empty">(vazio)</div> : arr.map((e,idx)=>(\n                      <div key={idx} className="slot">{e.chave}<span className="pill">p{e.pagina}</span></div>\n                    ))}\n                  </div>\n                  {of.length > 0 && (\n                    <div className="overflow">\n                      <div className="overflow-head">Overflow</div>\n                      <div className="slot-list">\n                        {of.map((e,idx)=>(\n                          <div key={idx} className="slot of">{e.chave}<span className="pill">p{e.pagina}</span></div>\n                        ))}\n                      </div>\n                    </div>\n                  )}\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div style={{fontFamily:'Inter, system-ui, Arial', padding: 20, maxWidth: 1200, margin: '0 auto'}}>\n      <h1>Índice Hash Estático</h1>\n\n      {/* Entrada de dados */}\n      <section className="panel">\n        <h2>1) Dados</h2>\n        <div className="row">\n          <input ref={fileRef} type="file" accept=".txt" onChange={onFile} />\n          <button onClick={carregarDoGitHub}>Carregar do GitHub (466k palavras)</button>\n          <button onClick={usarExemplo}>Usar exemplo pequeno</button>\n        </div>\n        <p style={{opacity:.8, marginTop:8}}>O arquivo deve conter uma palavra por linha (chave única).</p>\n      </section>\n\n      {/* Parâmetros */}\n      <section className="panel">\n        <h2>2) Parâmetros</h2>\n        <div className="row">\n          <label><input type="checkbox" checked={usarNumPaginas} onChange={e=>setUsarNumPaginas(e.target.checked)} /> Informar número de páginas (em vez de tamanho da página)</label>\n        </div>\n        {!usarNumPaginas ? (\n          <div className="row">\n            <label>Tamanho da página (tuplas por página):&nbsp;\n              <input type="number" min={1} value={tuplasPorPagina} onChange={e=>setTuplasPorPagina(e.target.value)} />\n            </label>\n          </div>\n        ) : (\n          <div className="row">\n            <label>Número de páginas:&nbsp;\n              <input type="number" min={1} value={numPaginasInput} onChange={e=>setNumPaginasInput(e.target.value)} />\n            </label>\n          </div>\n        )}\n        <div className="row">\n          <label>Tamanho do bucket (FR):&nbsp;\n            <input type="number" min={1} value={fr} onChange={e=>setFr(e.target.value)} />\n          </label>\n        </div>\n        <div className="row">\n          <button onClick={construirIndice} disabled={!linhas.length}>Construir índice</button>\n        </div>\n      </section>\n\n      {/* Estatísticas gerais */}\n      {estat && (\n        <section className="panel">\n          <h2>3) Estatísticas</h2>\n          <ul className="stats">\n            <li><strong>NR</strong>: {estat.NR}</li>\n            <li><strong>FR</strong>: {estat.FR}</li>\n            <li><strong>NB</strong>: {estat.NB}</li>\n            <li><strong>Tamanho da página</strong>: {estat.tpp} tuplas</li>\n            <li><strong>Quantidade de páginas</strong>: {estat.numPaginas}</li>\n            <li><strong>Colisões</strong>: {estat.colisoes} ({estat.taxaColisoes.toFixed(3)}%)</li>\n            <li><strong>Overflows</strong>: {estat.qtdOverflow} ({estat.taxaOverflow.toFixed(3)}%)</li>\n          </ul>\n        </section>\n      )}\n\n      {/* Visual das Páginas (primeira e última) */}\n      {construido && (\n        <section className="panel">\n          <h2>4) Páginas (primeira e última)</h2>\n          <RenderPaginas />\n        </section>\n      )}\n\n      {/* Visual dos Buckets */}\n      {construido && (\n        <section className="panel">\n          <h2>5) Buckets e Overflow</h2>\n          <RenderBuckets />\n        </section>\n      )}\n\n      {/* Busca e Table Scan */}\n      {construido && (\n        <section className="panel">\n          <h2>6) Busca</h2>\n          <div className="row">\n            <input style={{minWidth:260}} placeholder="Digite a chave (palavra)" value={chaveBusca} onChange={e=>setChaveBusca(e.target.value)} />\n            <button onClick={buscarComIndice}>Buscar (índice)</button>\n            <button onClick={tableScan} disabled={!chaveBusca}>Table Scan</button>\n          </div>\n\n          <div className="grid" style={{display:'grid',gap:12,gridTemplateColumns:'repeat(auto-fit,minmax(260px,1fr))', marginTop: 12}}>\n            {resultadoBusca && (\n              <div className="card">\n                <h3>Resultado (Índice)</h3>\n                <pre className="box">{JSON.stringify(resultadoBusca, null, 2)}</pre>\n                <p><small>Custo estimado: {resultadoBusca.custoPaginas} leitura(s) de página.</small></p>\n              </div>\n            )}\n            {resultadoScan && (\n              <div className="card">\n                <h3>Resultado (Table Scan)</h3>\n                <pre className="box">{JSON.stringify(resultadoScan, null, 2)}</pre>\n                <p><small>Custo: {resultadoScan.custoPaginas} página(s) lida(s).</small></p>\n              </div>\n            )}\n            {resultadoBusca && resultadoScan && (\n              <div className="card">\n                <h3>Comparação</h3>\n                <p><strong>Diferença de tempo</strong>: {diffTempo} ms (scan − índice)</p>\n                <p><small>Valores positivos indicam que o índice foi mais rápido.</small></p>\n              </div>\n            )}\n          </div>\n        </section>\n      )}\n\n      {/* Estilos básicos inline (para não depender de CSS externo) */}\n      <style>{`\n        h1 { font-size: 28px; margin-bottom: 12px; }\n        h2 { font-size: 20px; margin: 12px 0; }\n        h3 { margin: 6px 0 8px; }\n        .panel { border: 1px solid #e5e7eb; padding: 12px; border-radius: 10px; margin: 14px 0; background: #fff; }\n        .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }\n        input[type='number'], input[type='text'] { padding: 6px 8px; }\n        button { padding: 6px 10px; border: 1px solid #e5e7eb; background: #111827; color: #fff; border-radius: 8px; cursor: pointer; }\n        button[disabled] { opacity: .5; cursor: not-allowed; }\n        .stats { display: grid; grid-template-columns: repeat(auto-fit,minmax(180px,1fr)); gap: 8px; list-style: none; padding: 0; }\n        .stats li { background:#f9fafb; border:1px solid #eee; border-radius:8px; padding:8px; }\n        .card { border:1px solid #e5e7eb; border-radius:10px; background:#fff; padding:10px; }\n        .box { background:#0b1020; color:#d6e2ff; padding:10px; border-radius:8px; max-height:220px; overflow:auto; }\n        .bucket { border:1px solid #e5e7eb; border-radius:10px; overflow:hidden; background:#fff; }\n        .bucket-head { background:#111827; color:#fff; padding:6px 10px; font-weight:600; }\n        .bucket-body { display:flex; gap:10px; padding:10px; }\n        .slot-list { display:flex; flex-direction:column; gap:6px; min-width: 160px; }\n        .slot { padding:6px 8px; background:#f3f4f6; border:1px solid #e5e7eb; border-radius:8px; display:flex; justify-content:space-between; align-items:center; }\n        .slot.empty { opacity:.6; font-style:italic; }\n        .overflow { border-left:3px solid #ef4444; padding-left:10px; }\n        .overflow-head { font-size:12px; color:#ef4444; font-weight:700; margin-bottom:6px; }\n        .slot.of { background:#fff1f2; }\n        .pill { font-size:11px; padding:2px 6px; background:#111827; color:#fff; border-radius:9999px; margin-left:8px; }\n      `}</style>\n    </div>\n  );\n}
